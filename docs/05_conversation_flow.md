# 会話フロー

## 全体フロー

```
[初回接触] → [名前登録] → [生年月日登録] → [好きな人の名前登録] → [好きな人の生年月日登録] → [マッチング判定]
```

---

## 詳細フロー

### 1. 初回接触
**状態**: ユーザーがまだDBに存在しない

```
User: 「こんにちは」（任意のメッセージ）
Bot:  「はじめまして。あなたの名前を教えて、ね」
```

#### システム動作
- Usersテーブルに新規レコード作成
- `registration_step = "awaiting_name"`

---

### 2. 名前登録
**状態**: `registration_step = "awaiting_name"`

```
User: 「しのざわひろ」
Bot:  「しのざわひろ、ね。生年月日は？（例：2009-12-21）」
```

#### システム動作
- `name`フィールドに保存
- `registration_step = "awaiting_birthday"`に更新

---

### 3. 生年月日登録
**状態**: `registration_step = "awaiting_birthday"`

```
User: 「2009-12-21」
Bot:  「登録できた、よ。好きな人の名前は？」
```

#### システム動作
- `birthday`フィールドに保存
- `registration_step = "completed"`に更新

---

### 4. 好きな人の名前登録
**状態**: `registration_step = "completed"`（自分の情報は登録済み）

```
User: 「つきむらてまり」
Bot:  「その人の生年月日は？」
```

#### システム動作
- `temp_crush_name`フィールドに保存（次のステップで使用）
- `registration_step = "awaiting_crush_birthday"`に更新

**SQL例**:
```sql
UPDATE users
SET temp_crush_name = 'つきむらてまり',
    registration_step = 'awaiting_crush_birthday'
WHERE line_user_id = ?
```

---

### 5. 好きな人の生年月日登録
**状態**: `registration_step = "awaiting_crush_birthday"`

```
User: 「2010-04-04」
Bot:  「登録した、よ。相思相愛なら通知する、ね」
```

#### システム動作
1. Likesテーブルに登録
   - `from_user_id`: ユーザーのLINE User ID
   - `to_name`: つきむらてまり（ひらがな）
   - `to_birthday`: 2010-04-04
2. マッチングチェック（後述）
3. `registration_step = "completed"`に戻す
4. `temp_crush_name`フィールドをクリア

---

### 6. マッチング判定

#### ケースA: マッチングなし
```
Bot: 「登録した、よ。相思相愛なら通知する、ね」
```

#### ケースB: マッチング成立
```
Bot (ユーザーAへ): 「相思相愛、みたい。おめでとう。」
Bot (ユーザーBへ): 「相思相愛、みたい。おめでとう。」
```

#### マッチング判定ロジック

**手順**:
1. Likesテーブルをクエリ：
   - 条件: `to_name`がユーザーの名前、`to_birthday`がユーザーの生年月日
   - かつ`matched = 0`（まだマッチング済みでない）
2. 結果があれば相思相愛
3. 両方のLikesレコードの`matched`を`1`に更新
4. 両方のユーザーにPush Message送信

**SQL例**:
```sql
-- マッチング相手を検索（ユーザーAが「つきむらてまり 2010-04-04」を登録した場合）
-- 「つきむらてまり」が「しのざわひろ 2009-12-21」を好きと登録しているかチェック
SELECT l.from_user_id, u.name
FROM likes l
JOIN users u ON l.from_user_id = u.line_user_id
WHERE l.to_name = 'しのざわひろ'
  AND l.to_birthday = '2009-12-21'
  AND l.matched = 0;

-- マッチングしていれば、両方のレコードを更新
UPDATE likes SET matched = 1 WHERE from_user_id = ?;  -- ユーザーA
UPDATE likes SET matched = 1 WHERE from_user_id = ?;  -- ユーザーB
```

---

## 状態遷移図

```
[新規ユーザー]
    ↓
[awaiting_name] ← 名前を聞く
    ↓ (名前受信)
[awaiting_birthday] ← 生年月日を聞く
    ↓ (生年月日受信)
[completed] ← 好きな人の名前を聞く
    ↓ (好きな人の名前受信)
[awaiting_crush_birthday] ← 好きな人の生年月日を聞く
    ↓ (生年月日受信)
[completed] + Likes登録 + マッチング判定
```

---

## 会話例（完全版）

### ユーザーA（篠澤広）の会話

```
User A: 「使ってみる」
Bot:    「はじめまして。あなたの名前を教えて、ね（ひらがなで）」

User A: 「しのざわひろ」
Bot:    「しのざわひろ、ね。生年月日は？（例：2009-12-21）」

User A: 「2009-12-21」
Bot:    「登録できた、よ。好きな人の名前は？（ひらがなで）」

User A: 「つきむらてまり」
Bot:    「その人の生年月日は？」

User A: 「2010-04-04」
Bot:    「登録した、よ。相思相愛なら通知する、ね」
```

### ユーザーB（月村手毬）の会話

```
User B: 「はじめまして」
Bot:    「はじめまして。あなたの名前を教えて、ね（ひらがなで）」

User B: 「つきむらてまり」
Bot:    「つきむらてまり、ね。生年月日は？（例：2009-12-21）」

User B: 「2010-04-04」
Bot:    「登録できた、よ。好きな人の名前は？（ひらがなで）」

User B: 「しのざわひろ」
Bot:    「その人の生年月日は？」

User B: 「2009-12-21」
Bot:    「相思相愛、みたい。おめでとう。」
        ← この瞬間、User Aにも通知が届く
```

---

## エッジケース（スコープ外）

以下は現時点で考慮しない：

### 入力フォーマットエラー
- 生年月日が不正な形式（例：「12月21日」）
- → 後で実装

### 登録済みユーザーが再度メッセージ
- 好きな人を変更したい
- 自分の情報を変更したい
- → 後で実装（コマンド機能が必要）

### 同姓同名・同じ生年月日
- 同じ名前（ひらがな）・同じ誕生日の人がいた場合
- → **後から登録した人の情報で単純に上書きされる**（意図的な仕様、確認メッセージなし）
- 例：「しのざわひろ 2009-12-21」が2人いた場合、後から登録した人が有効になる
- ひらがな化により表記ゆれを防ぎ、衝突確率を下げている

### 好きな人の複数登録
- 現在は1人のみ
- → 仕様として1人のみに固定

---

## メッセージ文言（案）

以下は提案。プロデューサーが好きに変更していい、よ。

| シーン | メッセージ |
|--------|-----------|
| 初回接触 | はじめまして。あなたの名前を教えて、ね（ひらがなで） |
| 名前受信後 | {名前}、ね。生年月日は？（例：2009-12-21） |
| 生年月日受信後 | 登録できた、よ。好きな人の名前は？（ひらがなで） |
| 好きな人名前受信後 | その人の生年月日は？ |
| 好きな人登録完了 | 登録した、よ。相思相愛なら通知する、ね |
| マッチング成立 | 相思相愛、みたい。おめでとう。 |
